#!/usr/bin/env python

HELP_TEXT = """
git-gpg - remote encrypted git repositories.

Usage:

  git gpg add REMOTE_NAME ARCHIVE_PATH

  git gpg remove REMOTE_NAME

  git gpg push [OPTIONS] REMOTE_NAME [REFSPEC]
  - See `git help push` for options.

  git gpg pull [OPTIONS] REMOTE_NAME [REFSPEC]
  - See `git help pull` for options.
"""

import hashlib
import os
import re
import shutil
import subprocess
import sys
import time

def error_and_exit(s):
    print(s)
    exit(-1)

def ensure_path(path):
    if not os.path.exists(path):
        os.makedirs(path)

def delete_path(path):
    if os.path.exists(path):
        shutil.rmtree(path)

def get_staging_path(remote_name):
    return os.path.join(".git", "gpg_remotes", remote_name)

def assert_git_directory():
    """
    Exit with error if we are not in a git repo.
    """
    if not os.path.isdir(".git"):
        error_and_exit("Not in a git repository.")

def assert_remote_exists(remote_name):
    """
    Exit with error if the remote is missing or not configured correctly.
    """
    staging_path = get_staging_path(remote_name)
    if not os.path.exists(staging_path):
        error_and_exit("Missing '%s'." % staging_path)

def assert_remote_unchanged(remote_name):
    """
    Exit with error if the remote repo has been updated since we last pulled changes.
    """
    do_fetch_remote_lock(remote_name)
    if get_config(remote_name, "remote-lock") != get_config(remote_name, "local-lock"):
        error_and_exit("The gpg remote may have changed. Run `git gpg pull %s`" % remote_name)

def get_remote_blob_path(args):
    """
    Return the remote blob path specified on the command line.
    """
    if len(sys.argv) < 2:
        error_and_exit("Must provide a remote blob remote path.")
    return sys.argv[1]

def get_current_git_branch():
    """
    Return the current git branch.
    """
    return subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"]).strip()

def set_config(remote_name, key, value):
    new_key = "gpg-remote.%s.%s" % (remote_name, key)
    subprocess.check_call(["git", "config", "--local", new_key, value])

def get_config(remote_name, key):
    new_key = "gpg-remote.%s.%s" % (remote_name, key)
    p = subprocess.Popen(["git", "config", new_key], stdout = subprocess.PIPE)
    p.wait()
    if p.returncode == 0:
        return p.communicate()[0].strip()
    else:
        return None

def unset_config(remote_name, key):
    new_key = "gpg-remote.%s.%s" % (remote_name, key)
    subprocess.check_output(["git", "config", "--unset", new_key])

def get_user_email():
    return subprocess.check_output(["git", "config", "user.email"]).strip()

def generate_lock_value():
    s = get_user_email() + str(time.time()*1000000)
    return hashlib.md5(s).hexdigest()

def rewrite_git_arguments(args):
    """
    Given a list of git arguments, rewrite the arguments to replace the remote
    gpg name with the staging repository path.

    Return (remote_name, new_args).
    """
    # Get a list of all remotes.
    remotes = []
    for line in subprocess.check_output(["git", "config", "--get-regexp", "gpg-remote.*"]).split("\n"):
        m = re.match(".*\.(.*)\..* .*", line)
        if m != None:
            remotes.append(m.group(1))

    # Rewrite the pull args to replace remote name with the staging repository path.
    remote_name = None
    new_args = []
    args = list(args)
    while len(args) > 0:
        arg = args.pop(0)
        if arg in remotes:
            remote_name = arg
            staging_repo_path = os.path.join(get_staging_path(remote_name), "git")
            new_args.append(staging_repo_path)
        else:
            new_args.append(arg)
    new_args.extend(args)

    # Ensure that we have found a remote name.
    if remote_name == None:
        error_and_exit("Could not find a gpg remote by that name.")

    # Return.
    return (remote_name, new_args)

###
# Commands
###

def do_help():
    print(HELP_TEXT)

def do_add(remote_name, remote_blob_path):
    """
    Add an encrypted remote repository.
    """
    assert_git_directory()

    # Assemble some paths.
    path = get_staging_path(remote_name)
    if os.path.exists(path):
        error_and_exit("The remote name '%s' already exists." % remote_name)
    ensure_path(path)

    # Set configuration.
    user_email = get_user_email()
    set_config(remote_name, "url", remote_blob_path)
    set_config(remote_name, "gpg-recipient", user_email)

    print(get_config(remote_name, "url"))

    # Success!
    print("Added gpg remote '%s'." % remote_name)

def do_remove(remote_name):
    """
    Remove an encrypted remote repository."
    """
    assert_git_directory()

    # Remove the files.
    path = get_staging_path(remote_name)
    delete_path(path)

    # Unset configuration.
    unset_config(remote_name, "url")
    unset_config(remote_name, "gpg-recipient")

    # Success!
    print("Removed gpg remote '%s'." % remote_name)

def do_fetch_remote_lock(remote_name):
    """
    Refresh the lock value.
    """

    # Prepare some vars.
    remote_lock_path = get_config(remote_name, "url") + ".lock"
    staging_path     = get_staging_path(remote_name)
    local_lock_path  = os.path.join(staging_path, "remote.gpg") + ".lock"

    # Fetch the remote lock value.
    if subprocess.call(["rsync", remote_lock_path, local_lock_path], stdout = subprocess.PIPE, stderr = subprocess.PIPE) == 0:
        with open(local_lock_path, 'r') as f:
            lock_value = f.read()
        set_config(remote_name, "remote-lock", lock_value)
    else:
        lock = generate_lock_value()
        set_config(remote_name, "local-lock", lock)
        set_config(remote_name, "remote-lock", lock)

def do_push_local_lock(remote_name):
    # Prepare some vars.
    remote_lock_path = get_config(remote_name, "url") + ".lock"
    staging_path     = get_staging_path(remote_name)
    local_lock_path  = os.path.join(staging_path, "remote.gpg") + ".lock"
    lock_value       = get_config(remote_name, "local-lock")

    # Write the lock value.
    with open(local_lock_path, 'w') as f:
        f.write(lock_value)

    # Fetch the remote lock value.
    if subprocess.call(["rsync", local_lock_path, remote_lock_path], stdout = subprocess.PIPE, stderr = subprocess.PIPE) != 0:
        error_and_exit("Could not update the remote lock.")

def do_fetch(remote_name):
    """
    Download the remote blob.
    Decrypt the blob into the staging repository.
    """
    assert_git_directory()
    assert_remote_exists(remote_name)

    # Prepare some vars.
    remote_blob_path = get_config(remote_name, "url")
    staging_path     = get_staging_path(remote_name)
    local_blob_path  = os.path.join(staging_path, "remote.gpg")
    gpg_recipient    = get_config(remote_name, "gpg-recipient")

    # Fetch the blob.
    if subprocess.call(["rsync", "--progress", remote_blob_path, local_blob_path]) == 0:
        # Get the blob, now decrypt it.
        if subprocess.call(["gpg-zip", "--decrypt", "--recipient", gpg_recipient, "remote.gpg"], cwd=staging_path) != 0:
            error_and_exit("Could not decrypt '%s'" % local_blob_path)

        # Fetch the remote lock and update the local lock.
        do_fetch_remote_lock(remote_name)
        set_config(remote_name, "local-lock", get_config(remote_name, "remote-lock"))

        # Success!
        print("Fetched from gpg remote '%s'." % remote_name)
    else:
        staging_repo_path = os.path.join(staging_path, "git")
        subprocess.call(["git", "init", "--bare", staging_repo_path])
        print("Initialized new gpg remote '%s'." % remote_name)

def do_upload(remote_name):
    """
    Tar, gzip, and encrypt the staging repository.
    Upload to the remote blob.
    """
    assert_git_directory()
    assert_remote_exists(remote_name)

    # Ensure that we know about the latest copy of the blob.
    assert_remote_unchanged(remote_name)

    # Update the lock. We do this first so that if other processes have tried
    # to upload changes, then both of them encounter an error and back off.
    new_lock = generate_lock_value()
    set_config(remote_name, "local-lock", new_lock)
    set_config(remote_name, "remote-lock", new_lock)
    do_push_local_lock(remote_name)

    # Prepare some vars.
    remote_blob_path = get_config(remote_name, "url")
    staging_path        = get_staging_path(remote_name)
    local_blob_path  = os.path.join(staging_path, "remote.gpg")
    gpg_recipient       = get_config(remote_name, "gpg-recipient")

    # Remove the local blob path if it exists.
    if os.path.exists(local_blob_path):
        os.remove(local_blob_path)

    # Create the blob.
    if subprocess.call(["gpg-zip", "--encrypt", "--recipient", gpg_recipient, "--output", "remote.gpg", "git"], cwd=staging_path) != 0:
        error_and_exit("Could not encrypt '%s'." % os.path.join(staging_path, "git"))

    # Upload the blob.
    if subprocess.call(["rsync", "--progress", "--delay-updates", local_blob_path, remote_blob_path]) != 0:
        error_and_exit("Could not upload '%s' to '%s'." % (local_blob_path, remote_blob_path))

    # Ensure that we know about the latest copy of the blob.
    assert_remote_unchanged(remote_name)

    # Generate a lock. Set the local and remote lock.
    new_lock = generate_lock_value()
    set_config(remote_name, "remote-lock", new_lock)
    set_config(remote_name, "local-lock", new_lock)
    do_push_local_lock(remote_name)

    # Success!
    print("Uploaded to gpg remote '%s'." % remote_name)

def do_pull(*args):
    """
    Fetch changes from the remote blob into our staging
    repository, then pull them into the local repository.
    """
    assert_git_directory()

    # Process the args.
    remote_name, git_arguments = rewrite_git_arguments(args)

    # Fetch from the remote repo into the staging repository.
    do_fetch(remote_name)

    # Pull from staging repository into our local repository.
    if subprocess.call(["git", "pull"] + git_arguments) == 0:
        print("Pulled from gpg remote '%s'." % remote_name)

def do_push(*args):
    """
    Push changes from the local repository into the staging repository, then
    push them to the remote blob.
    """
    assert_git_directory()

    # Process the args.
    remote_name, git_arguments = rewrite_git_arguments(args)

    # Make sure the remote hasn't changed.
    assert_remote_unchanged(remote_name)

    # Make sure we have a local repo.
    staging_path     = get_staging_path(remote_name)
    staging_repo_path = os.path.join(staging_path, "git")
    if not os.path.exists(staging_repo_path):
        subprocess.call(["git", "init", "--bare", staging_repo_path])
        print("Initialized new gpg remote '%s'." % remote_name)

    # Push from our local repository into the staging repository.
    if subprocess.call(["git", "push"] + git_arguments) == 0:
        do_upload(remote_name)
        print("Pushed to gpg remote '%s'." % remote_name)

###
# Run
###
# Calls do_add, do_remove, do_pull, etc.
script_name = sys.argv.pop(0)
if len(sys.argv) == 0:
    do_help()
else:
    locals()["do_" + sys.argv.pop(0)](*sys.argv)




